传warehouseid
传补货类型。
by sku 订单触发的补货
预配成功，分配失败，按照指定批次补货 by lotNum
产品设有多个动态拣货位时，按照拣货位库存的合计数进行下限的判断
按订单触发的补货，则按照订单数量补满，即使超过了上限
@STOP='Y'循环寻找空库位时不做库存下限的校验
非标准包装，@QtyUOM_Read取值应该是LOTATT12
一次补货轮回只从一个From库位产生补货任务，即使没有达到库存上限(由于产品没有标准包装，无法确定补货的上限，所以只能把补货上限设置的很高 -- 亚鼎模式)
动态拣货位补货时，以拣货位汇总的数量作为判断下限的依据
ByTimer定时补货

按照箱拣货位和件拣货位判断是否存在相同的补货任务
非标包装时补货单位应该为CS

FWDLoc拣货位
LotAtt01 待补货的库存的批次属性
LotNum_F 拣货位中已有库存的批次
LotAtt01_F 拣货位中已有库存的批次属性
Qty_ReplenishIng 最小补货单位对应的数量(整数）

  RPL_QTY_ALC 计算补货数量时是否扣减分配数

Priority优先级
qtypending订单补货的需求量（待补货数量）
upLimit_库存上限
QTY_s拣货位可用库存
FWDLoc
SKU_S=*批号在拣货位中不存在  要补货的sku


QtyRPIn	补货待上架数量
QtyRPOut	补货待下架数量
QtyMVIn	待移入数量
QtyMVOut	待移出数量
QtyOnHold	冻结数
QtyPA	待上架数量
QtyAllocated	分配数量
QtyOnHold	冻结数
OnHoldLocker  冻结人



inv_lot_att
LotNum	批次号 char(10)	key
CustomerID	客户
SKU	产品
LotAtt01	批次属性01
LotAtt02	批次属性02
LotAtt03	批次属性03
LotAtt04	批次属性04
LotAtt05	批次属性05
LotAtt06	批次属性06
LotAtt07	批次属性07
LotAtt08	批次属性08
LotAtt09	批次属性09
LotAtt10	批次属性10
LotAtt11	批次属性11
LotAtt12	批次属性12
ReceivingTime首次产生批次的时间


----------
不循环查找新的库位 @stop=N
1. 如果客户传入的动作是定时补货(常规补货)，设置优先级为3，否则优先级设置为1
       定义一个@LOT_#12_PKG并设置为N 批次属性12是否用作包装的跟踪
       然后查询出客户端系统里面value_string的值并当做@LOT_#12_PKG的值
       设置状态码，执行存储过程，清空空库存的库位
       if状态码不是000，抛出异常代码
设置@RPL_QTY_ALC='N' 是否基于分配数计算拣货位可用库存
然后把系统配置里面的RPL_QTY_ALC赋给 @RPL_QTY_ALC
-----
#2. 如果客户传入的动作不是按批次补货（针对医药行业）:
      1. 如果不是基于分配数计算拣货位可用库存，那么开始执行：
          1.如果客户传入的动作是定时补货（常规补货），定义一个CUR_Replenish游标：
            - 基于FwdLOC拣货位不是动态拣货位，且warehouseid是传进来的参数，
            - 且循环级别表里边的循环等级是空或者定时补货参数是Y
            - 且拣货位的库位类型使用的不是AP(补充拣货位)，而是其他箱捡，件捡，存储和过渡库位等等。
            - 且只有存在库区里Allow_cs_rpl='y'或者ALLow_ea_rpl='y'和库位不是件捡库位，还要求补货源有库存。
            - 那么就开始从拣货位上查找出客户，产品和拣货位编组及最大的上下限并从小于下限的开始排序。
            ------
          2. 如果客户传入的by customer,又定义一个游标
            - 小于下限，拣货位不是动态拣货位且不是补充拣货位，且循环级别表里边的循环等级是空或者定时补货参数是Y
            - 那么就开始从拣货位上查找出客户，产品和拣货位编组及最大的上下限并从小于下限的开始排序。
            -----

          3. 如果客户传入的动作是订单产生的补货，定义一个游标
          - 只要拣货位不是动态拣货位且类型用的不是AP(补充拣货位)
          - 那么就开始从拣货位上查找出客户，产品和拣货位编组
          -------
     2. 如果是 基于分配数计算拣货位可用库存(拣货位库存只要分配即在计算补货数量时扣减）
          1. 如果是常规定时补货。定义游标。搜索出客户，产品和拣货位编组，并检测拣货位的数量是否小于等于拣货位的下限总和的数量，（条件同1.1）当然是要基于拣货位不是动态拣货位且类型不是AP，库区里Allow_cs_rpl='y'或者ALLow_ea_rpl='y'和库位不是件捡库位，还要求补货源有库存，拣货位上查找出客户，产品和拣货位编组及最大的上下限并从小于下限的开始排序。
          -----
          2. 如果是订单产生的紧急补货。定义游标。只要求拣货位不是动态拣货位且类型用的不是AP(补充拣货位)，然后搜索出客户，产品和拣货位编组
------------
#3. 根据动作即补货来源，打开游标。并赋值给存储过程定义的客户，sku,和拣货位编组及上下限。开始执行：
   1. 检测一系列参数在bas_package和bas_sku中是否存在，不存在抛出888BAS_Package,OPEN，返回返回码、
   2. 读取拣货位信息，包含补货来源是按存储位补还是按箱补的字段及最小补货单位和上下限的字段，并order by了LogicalSequence，然后插入到存储过程过。
   3. 如果上一步没问题，就根据上一步的最小补货单位，判断EA'IP'	CS'   PL'   OT'，插入到@QtyUOM_Read变量中（读取到的单位）
    - 如果最小补货单位没有，抛出110+sku_R异常。
      ------
   4. RPL_QTY_ALC如果是N，那么补货数量是 上限-已有库存-补货上架，否则 补货数量是：上限-已有库存-补货上架+已分配数量
   5. 如果补货数量小于最小补货单位数量，则不补。否则补货数量如下：
      - 补货数量必须换算为整包装(不足一个最小单位数量按照一个最小单位来补,超过最小单位数量按照整数倍补货：
  ```SQL  
    Set @Qty_ReplenishIng=@Qty_Allow/(@MinimumReplenishQty_F * @QtyUOM_Read)
	  Set @Qty_Allow=@Qty_ReplenishIng*(@MinimumReplenishQty_F * @QtyUOM_Read)
  ```

6. 货源：从哪儿补货：
  1.（固定了拣货位的补货）如果补货数量大于等于读取到的最小补货单位数量，那个就根据勾选的补货来源查询。
     - 根据库存周转规则对补货排序。：定义一个游标，搜索该SKU的库存周转规则顺序。 ：
     - 依次排序为生产日期，入库日期，失效日期,如果能搜索到，就分配赋值给存储过程。并定义一个ordersql为按批次号。否则ordersql='order by'方便后面拼接字符串连接。
     - 定义周转次数，如果该商品是当天第一次周转那直接以LocationUsage,PickLogicalSequence筛除库位（先CS，在EA,在RS）
     - 如果该商品 不是第一次周转，@i>1,那么先以生产日期排出筛选出靠前的库位，在以入库日期筛出，其次以失效日期筛选
     - 如果补货数量》@Qty_INV - @QtyAllocated_INV - @QtyRPOut_INV - @QtyMVOut_INV - @QtyOnHold_INV 补货位可用库存，那么Qty_ReplenishIng_Temp=刚刚的可用库存。否则@Qty_Allow就等于Qty_ReplenishIng_Temp
     - 如果有非整箱补货发生，则需要将待补货数量的零头去掉。
     - 判定包装bas_package中的包装级别字段,最小补货单位为CS包装级别，或者最小单位是托盘级别时，并且将去整后的补货数量（EA级别）与读取到的最小单位数量做比较，如果比它大，那就把最小补货单位的数量临时存储起来，否则就把去整后的补货数量作为最小补货单位的数量
      判定：
       if 去整的补货数量>0,搜索批次号为***的批次属性1-12并赋值给存储过程， 然后传参数执行另一个存储过程，获取订单的流水号，asn号和so单号,没获取到，回滚事务
      - 对单位进行转换。然后插入到tsk_taskLists表里。之后更新INV_lot_loc_id（库存余量）
      -----
      - 如果补货成功，判断巡回是否从一个源补货，如果是那么补货数量设置为0
  -----
    2.（动态拣货位的补货）：
      1. 补货来源是常规补货，定义一个游标：
        - 将汇总动态拣货位的数量和库存,且拣货位类型不是'AP'(补充拣货位)，补货源是RS和CS
        ------
      2. 补货来源是订单紧急补货，定义一个游标。
        - 与1不同的是没有做动态拣货位的汇总和没有做拣货位的下限判断
        -----
      3. 顺序读取需要进行补货的库位。判定@stop=Y.（要寻找一个新的库位）：
        - 待补货的批号与当前库位不一致，不能混放，会产生STOP=Y
        - 补完一个库位发现没有达到动态拣货位总数(A类)
        - 拣货位上限超出，不补货，拣货位数量超出，不产生任务。
        ---
        ----

7. 如果拣货区没有拣货位，通过上架规则寻找一个动态拣货位
    - 然后检查包装，确定数量和补货来源，库存周转规则排序，零头处理，包装级别label检测,
    补货成功，判定是否已经补够动态拣货位数量，没有则寻找新库位，继续补货。
    -----
    -----
------
    8. 医药行业补货。
